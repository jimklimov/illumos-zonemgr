#!/usr/bin/bash

# Portability Note: BASH-specific syntax is likely present below, so
# the interpreter is fixed in the shebang above. YMMV with other shells.
#
# This is a script to manage illumos zones lifecycle for essentially
# disposable zones -- such as single-use build environments that are
# clones of a golden template env, which has its own update schedule
# (if any).
#
# This file and its contents are supplied under the terms of the
# Common Development and Distribution License ("CDDL"). You may
# only use this file in accordance with the terms of the CDDL.
#
# A full copy of the text of the CDDL should have accompanied this
# source. A copy of the CDDL is also available via the Internet at
# http://www.illumos.org/license/CDDL.
#

#
# Copyright 2016-2017, Jim Klimov. All rights reserved.
#

############################################################################
# General helpers
############################################################################

if [ -n "${BASH-}" ]; then
    # A bash-ism, should set the exitcode of the rightmost failed command
    # in a pipeline, otherwise e.g. exitcode("false | true") == 0
    set -o pipefail 2>/dev/null || true
    echo_E() { echo -E "$@"; }
    echo_e() { echo -e "$@"; }
else
    echo_E() { /bin/echo -E "$@"; }
    echo_e() { /bin/echo -e "$@"; }
fi

## Store some important CLI values. DO NOT "export" THESE!
[ -z "${_SCRIPT_STARTPWD-}" ] && _SCRIPT_STARTPWD="`pwd`"
[ -z "${_SCRIPT_PATH-}" ] && _SCRIPT_PATH="$0"
[ -z "${_SCRIPT_NAME-}" ] && _SCRIPT_NAME="`basename "${_SCRIPT_PATH}"`"
_SCRIPT_ARGS="$*"
_SCRIPT_ARGC="$#"

### Set the default language
[ -z "${LANG-}" ] && LANG=C
[ -z "${LANGUAGE-}" ] && LANGUAGE=C
[ -z "${LC_ALL-}" ] && LC_ALL=C
[ -z "${TZ-}" ] && TZ=UTC
export LANG LANGUAGE LC_ALL TZ

PATH="/sbin:/usr/sbin:/usr/bin:/usr/gnu/bin:/usr/sfw/bin:$PATH"
export PATH

### Empty and non-numeric and non-positive values should be filtered out here
is_positive() {
    [ -n "$1" -a "$1" -gt 0 ] 2>/dev/null
}
default_posval() {
    eval is_positive "\$$1" || eval "$1"="$2"
}

### Caller can disable specific debuggers by setting their level too
### high in its environment variables for a specific script run.
### Scripts can use this mechanism to set flexible required-verbosity
### levels for their messages.
ZONEMGR_DEBUGLEVEL_NOOP="-1"
# logmsg_echo() adds no prefix and prints the message if ZONEMGR_DEBUG>=$1
# (or ZONEMGR_DEBUGLEVEL_ECHO if $1 is not a number)
default_posval ZONEMGR_DEBUGLEVEL_ECHO       0

# Standard stuff
default_posval ZONEMGR_DEBUGLEVEL_ERROR      1
default_posval ZONEMGR_DEBUGLEVEL_WARN       2
default_posval ZONEMGR_DEBUGLEVEL_INFO       3
default_posval ZONEMGR_DEBUGLEVEL_TRACE      4
default_posval ZONEMGR_DEBUGLEVEL_DEBUG      5

# Custom stuff for specific routines
default_posval ZONEMGR_DEBUGLEVEL_RUN        $ZONEMGR_DEBUGLEVEL_TRACE
default_posval ZONEMGR_DEBUGLEVEL_PIPESNIFFER $ZONEMGR_DEBUGLEVEL_DEBUG

# Semihack used below to enable "set -x" by very large debug level
default_posval ZONEMGR_DEBUGLEVEL_TRACEEXEC  200
default_posval ZONEMGR_DEBUGLEVEL_TIME_RUN 99

### Default debugging/info/warning level for this lifetime of the script
### Messages are printed if their assigned level is at least ZONEMGR_DEBUG
### The default of "3" allows INFO messages to be printed or easily
### suppressed by change to a smaller number. The level of "2" is default
### for warnings and "1" for errors, and a "0" would likely hide most
### such output. "Yes" bumps up a high level to enable even greater debug
### details, while "No" only leaves the default errors and warnings.
case "${ZONEMGR_DEBUG-}" in
    ""|"-")
        ZONEMGR_DEBUG="$ZONEMGR_DEBUGLEVEL_INFO"
        ;;
    [Yy]|[Yy][Ee][Ss]|[Oo][Nn]|[Tt][Rr][Uu][Ee])     ZONEMGR_DEBUG=99 ;;
    [Nn]|[Nn][Oo]|[Oo][Ff][Ff]|[Ff][Aa][Ll][Ss][Ee]) ZONEMGR_DEBUG="$ZONEMGR_DEBUGLEVEL_WARN" ;;
esac
[ "$ZONEMGR_DEBUG" -ge -1 ] 2>/dev/null || ZONEMGR_DEBUG="$ZONEMGR_DEBUGLEVEL_INFO"
[ "$ZONEMGR_DEBUG" -ge -1 ] 2>/dev/null || ZONEMGR_DEBUG=3

### This is prefixed before ERROR, WARN, INFO tags in the logged messages
[ -z "$LOGMSG_PREFIX" ] && LOGMSG_PREFIX="ZONEMGR-"

logmsg_echo() {
    ### Optionally echoes a message, based on current debug-level
    ### Does not add any headers to the output line
        # By default, do echo unless $1 says otherwise

    WANT_DEBUG_LEVEL=$ZONEMGR_DEBUGLEVEL_ECHO
    if [ "$1" -ge 0 ] 2>/dev/null; then
        WANT_DEBUG_LEVEL="$1"
        shift
    else if [ x"$1" = x"" ] && [ $# -gt 0 ]; then shift; fi
    fi
    [ "$ZONEMGR_DEBUG" -ge "$WANT_DEBUG_LEVEL" ] 2>/dev/null && \
    echo_E "$@"
    :
}

logmsg_info() {
    WANT_DEBUG_LEVEL=$ZONEMGR_DEBUGLEVEL_INFO
    if [ "$1" -ge 0 ] 2>/dev/null; then
        WANT_DEBUG_LEVEL="$1"
        shift
    else if [ x"$1" = x"" ] && [ $# -gt 0 ]; then shift; fi
    fi
    [ "$ZONEMGR_DEBUG" -ge "$WANT_DEBUG_LEVEL" ] 2>/dev/null && \
    echo_E "${LOGMSG_PREFIX}INFO: ${_SCRIPT_PATH}:" "$@"
    :
}

logmsg_warn() {
    WANT_DEBUG_LEVEL=$ZONEMGR_DEBUGLEVEL_WARN
    if [ "$1" -ge 0 ] 2>/dev/null; then
        WANT_DEBUG_LEVEL="$1"
        shift
    else if [ x"$1" = x"" ] && [ $# -gt 0 ]; then shift; fi
    fi
    [ "$ZONEMGR_DEBUG" -ge "$WANT_DEBUG_LEVEL" ] 2>/dev/null && \
    echo_E "${LOGMSG_PREFIX}WARN: ${_SCRIPT_PATH}:" "$@" >&2
    :
}

logmsg_error() {
    WANT_DEBUG_LEVEL=$ZONEMGR_DEBUGLEVEL_ERROR
    if [ "$1" -ge 0 ] 2>/dev/null; then
        WANT_DEBUG_LEVEL="$1"
        shift
    else if [ x"$1" = x"" ] && [ $# -gt 0 ]; then shift; fi
    fi
    [ "$ZONEMGR_DEBUG" -ge "$WANT_DEBUG_LEVEL" ] 2>/dev/null && \
    echo_E "${LOGMSG_PREFIX}ERROR: ${_SCRIPT_PATH}:" "$@" >&2
    :
}

logmsg_trace() {
    WANT_DEBUG_LEVEL=$ZONEMGR_DEBUGLEVEL_TRACE
    if [ "$1" -ge 0 ] 2>/dev/null; then
        WANT_DEBUG_LEVEL="$1"
        shift
    else if [ x"$1" = x"" ] && [ $# -gt 0 ]; then shift; fi
    fi
    [ "$ZONEMGR_DEBUG" -ge "$WANT_DEBUG_LEVEL" ] 2>/dev/null && \
    echo_E "${LOGMSG_PREFIX}TRACE: ${_SCRIPT_PATH}:" "$@" >&2
    :
}

logmsg_run() {
    WANT_DEBUG_LEVEL=$ZONEMGR_DEBUGLEVEL_RUN
    if [ "$1" -ge 0 ] 2>/dev/null; then
        WANT_DEBUG_LEVEL="$1"
        shift
    else if [ x"$1" = x"" ] && [ $# -gt 0 ]; then shift; fi
    fi
    [ "$ZONEMGR_DEBUG" -ge "$WANT_DEBUG_LEVEL" ] 2>/dev/null && \
    echo_E "${LOGMSG_PREFIX}TRACE-RUN: ${_SCRIPT_PATH}:" "$@" >&2
    :
}

logmsg_debug() {
    # A script can flexibly define its different debug messages via variables
    # with debug-levels assigned (and easily changeable) to different subjects
    WANT_DEBUG_LEVEL=$ZONEMGR_DEBUGLEVEL_DEBUG
    if [ "$1" -ge 0 ] 2>/dev/null; then
        WANT_DEBUG_LEVEL="$1"
        shift
    else if [ x"$1" = x"" ] && [ $# -gt 0 ]; then shift; fi
    fi

    [ "$ZONEMGR_DEBUG" -ge "$WANT_DEBUG_LEVEL" ] 2>/dev/null && \
        for LINE in "$@"; do
            echo_E "${LOGMSG_PREFIX}DEBUG[$WANT_DEBUG_LEVEL<=$ZONEMGR_DEBUG]: $LINE"
        done >&2
    :
}

tee_stderr() {
    ### This routine allows to optionally "sniff" piped streams, e.g.
    ###   prog1 | tee_stderr LISTING_TOKENS $DEBUGLEVEL_PRINTTOKENS | prog2
    TEE_TAG="PIPESNIFF:"
    [ -n "$1" ] && TEE_TAG="$1:"
    [ -n "$2" -a "$2" -ge 0 ] 2>/dev/null && \
        TEE_DEBUG="$2" || \
        TEE_DEBUG=$ZONEMGR_DEBUGLEVEL_PIPESNIFFER

    ### If debug is not enabled, skip tee'ing quickly with little impact
    [ "$ZONEMGR_DEBUG" -lt "$TEE_DEBUG" ] 2>/dev/null && cat || \
    while IFS= read -r LINE; do
        echo_E "$LINE"
        echo_E "${LOGMSG_PREFIX}$TEE_TAG" "$LINE" >&2
    done
    :
}

# This value can be set, at least in bash, to specify at which location
# the caller of DIE was in the scripts
SCRIPTLIB_DIE_FILENAME=""       # Which (maybe included) file caused the failure
SCRIPTLIB_DIE_FUNCNAME=""       # Which function failed, maybe main(), source() etc
SCRIPTLIB_DIE_LINENO=0          # Which line in the file (or function) failed?
SCRIPTLIB_DIE_SUBSHELL=-1       # Depth of automatic subshelling "()" "``" "$()"...
# These are inherited from caller in any shell:
SCRIPTLIB_DIE_SCRIPT_PATH=""
SCRIPTLIB_DIE_SCRIPT_NAME=""
SCRIPTLIB_DIE_SCRIPT_ARGS=""
SCRIPTLIB_DIE_SCRIPT_ARGC=-1
# This value is also a flag to decide if the SCRIPTLIB_DIE_* vars are to
# be consulted in the settraps() handler below rather than autodetection
# at the moment of trap execution (which may be already limited by shell).
SCRIPTLIB_DIE_ERRCODE=-1
die() {
    # The exit CODE can be passed as a variable, or as the first parameter
    # (if it is a number), both ways can be used for legacy reasons
    CODE="${CODE-1}"
    if [ "$1" -ge 0 ] 2>/dev/null; then
        CODE="$1"
        shift
    else if [ x"$1" = x"" ] && [ $# -gt 0 ]; then shift; fi
    fi
    [ "$CODE" -ge 0 ] 2>/dev/null || CODE=1
    for LINE in "$@" ; do
        echo_E "${LOGMSG_PREFIX-}FATAL: ${_SCRIPT_PATH-}:" "$LINE" >&2
    done
    # Set common vars for settraps() standard handler
    SCRIPTLIB_DIE_ERRCODE="${CODE}"
    SCRIPTLIB_DIE_SCRIPT_PATH="${_SCRIPT_PATH-}"
    SCRIPTLIB_DIE_SCRIPT_NAME="${_SCRIPT_NAME-}"
    SCRIPTLIB_DIE_SCRIPT_ARGS="${_SCRIPT_ARGS-}"
    SCRIPTLIB_DIE_SCRIPT_ARGC="${_SCRIPT_ARGC-}"
    if [ -n "${BASH}" ]; then
        # Detect who called die()
        SCRIPTLIB_DIE_LINENO="${BASH_LINENO[0]-}"
        SCRIPTLIB_DIE_FUNCNAME="${FUNCNAME[1]-}"
        SCRIPTLIB_DIE_FILENAME="${BASH_SOURCE[1]}"
        SCRIPTLIB_DIE_SUBSHELL="${BASH_SUBSHELL}"
    else
        # Definitions of LINENO vary greatly from shell to shell
        # In practice must be >= 1 if defined at all
        SCRIPTLIB_DIE_LINENO="${LINENO-}"
        [ "$SCRIPTLIB_DIE_LINENO" -ge 1 ] 2>/dev/null || SCRIPTLIB_DIE_LINENO=0
        SCRIPTLIB_DIE_FILENAME="${SCRIPTLIB_DIE_SCRIPT_NAME}"
        SCRIPTLIB_DIE_FUNCNAME=""
        SCRIPTLIB_DIE_SUBSHELL=-1
    fi
    exit $CODE
}

settraps_exit_clear() {
    # Reset the exit() handler to defaults, used in routines below
    for SS in EXIT SIGEXIT 0 ERR SIGERR; do trap "-" "$SS" 2>/dev/null || true; done
    set +E      # unset -o errtrace
}

settraps_nonfatal() {
    # While the legacy common settraps() wraps the caller's custom handler "$*"
    # with an exit(), this one is not fatal by itself, and it does not subshell
    # as it is intended to be used for interrupts, etc. And for settraps() too.
    # It detects and presets the variables that can be used by the caller's
    # trap handler, including one from settraps() below. Variables include:
    #   ERRCODE     Number of upstream exitcode that came into the trap
    #   ERRSIGNAL   Name of the signal as registered (HUP or SIGEXIT etc.)
    #   ERRFILE     File from which the trap was called, if we can guess it
    #   ERRFUNC     Function inside which failure, exit() or die() happened
    #   ERRLINE     Line in source file or function, if any (else empty)
    #   ERRPOS      String that combines available bits of _SCRIPT_NAME
    #               ERRFILE ERRFUNC ERRLINE into meaningful markup
    #   ERRTEXT     String that meaningfully combines ERRPOS ERRCODE ERRSIGNAL
    # The handler built into this routine does not report anything, it just
    # sets the variables above and calls the caller's handle - such as the
    # settrap() which reports stuff and exit()s with some code in the end.

    # Not all trap names are recognized by all shells consistently
    [ -z "${TRAP_SIGNALS-}" ] && TRAP_SIGNALS="EXIT QUIT TERM HUP INT ERR"
    for P in "" SIG; do for S in $TRAP_SIGNALS ; do
        if [ -n "$BASH" ] && [ "$S" = ERR ] ; then
            # If "set -e" aka "set -o errexit" would be used, inherit the trap
            set -o errtrace
        fi
        case "$1" in
            -|"") trap "$1" "$P$S" 2>/dev/null || true ;;
            *)    ERRHANDLER="$*"
                  case "$ERRHANDLER" in
                    *";"|*"; "|*";  ") ;;
                    *)    ERRHANDLER="$ERRHANDLER ;" ;;
                  esac
                  trap 'ERRCODE=$?; ERRSIGNAL="'"$P$S"'"; \
[ -z "${ERRIGNORE-}" ] && ERRIGNORE=no
if [ "${ERRSIGNAL-}" = "ERR" ] || [ "${ERRSIGNAL-}" = "SIGERR" ]; then
    set -o | egrep -i "^errexit.*off$" >/dev/null && ERRIGNORE=yes
fi
if [ "${ERRIGNORE-}" = no ]; then
  if [ -n "${SCRIPTLIB_DIE_ERRCODE-}" ] && [ "${SCRIPTLIB_DIE_ERRCODE-}" -ge 0 ] 2>/dev/null; then
    ERRFILE="$SCRIPTLIB_DIE_FILENAME"
    ERRFUNC="$SCRIPTLIB_DIE_FUNCNAME"
    ERRLINE="$SCRIPTLIB_DIE_LINENO"
    ERRCODE="$SCRIPTLIB_DIE_ERRCODE"
  else
    SCRIPTLIB_DIE_ERRCODE=""
    [ -n "${LINENO-}" ] && [ "${LINENO-}" -gt 0 ] 2>/dev/null && ERRLINE="${LINENO-}" || ERRLINE=""
    ERRFILE="${_SCRIPT_NAME-}"; ERRFUNC=""
    if [ -n "${BASH-}" ] 2>/dev/null; then
        [ -n "${FUNCNAME-}" -o -n "${FUNCNAME[0]-}" ] && ERRFUNC="${FUNCNAME[0]-}" || ERRFUNC=""
        ERRLINE="${BASH_LINENO[0]-}" && [ -n "$ERRLINE" ] || ERRLINE=0
        [ "$ERRLINE" -eq 0 ] && ERRLINE="${LINENO-}"
        [ -n "$ERRLINE" ] && [ "$ERRLINE" -gt 1 ] || ERRLINE=""
        ERRFILE="${BASH_SOURCE[0]-}"
    fi
  fi
  ERRPOS="${ERRFILE-}${ERRLINE:+:$ERRLINE}${ERRFUNC:+ :: $ERRFUNC()}"
  [ "`basename "${_SCRIPT_NAME-}"`" = "`basename "${ERRFILE-}"`" ] || ERRPOS="${_SCRIPT_NAME-} => ${ERRPOS-}"
  ERRTEXT="script (${ERRPOS-}) due to trapped signal (${ERRSIGNAL-}) with exit-code (${ERRCODE-})"
  [ -n "${SCRIPTLIB_DIE_ERRCODE-}" ] && ERRTEXT="${ERRTEXT-}, using die()"
  { (settraps_exit_clear; exit ${ERRCODE-} 2>/dev/null 2>&1); '"$ERRHANDLER"' } ;
else ERRIGNORE=""; fi ;' \
                    "$P$S" 2>/dev/null || true
                  ;;
        esac
    done; done
}

# These variables are tested for equality to "yes" when the trap is processed.
#   When a trap is handled by settraps(), should any message be printed?
[ -n "${SCRIPTLIB_TRAPWRAP_PRINT_MESSAGE-}" ] && [ x"${SCRIPTLIB_TRAPWRAP_PRINT_MESSAGE-}" != "x-" ] || \
    if [ "$ZONEMGR_DEBUG" -ge "$ZONEMGR_DEBUGLEVEL_ERROR" ]; then
        SCRIPTLIB_TRAPWRAP_PRINT_MESSAGE="yes"
    else
        SCRIPTLIB_TRAPWRAP_PRINT_MESSAGE="yes"
    fi
#   If SCRIPTLIB_TRAPWRAP_PRINT_MESSAGE==yes and cause is exit(0), still print?
[ -n "${SCRIPTLIB_TRAPWRAP_PRINT_EXIT0-}" ] && [ x"${SCRIPTLIB_TRAPWRAP_PRINT_EXIT0-}" != "x-" ] || \
    if [ "$ZONEMGR_DEBUG" -ge "$ZONEMGR_DEBUGLEVEL_DEBUG" ]; then
        SCRIPTLIB_TRAPWRAP_PRINT_EXIT0="yes"
    else
        SCRIPTLIB_TRAPWRAP_PRINT_EXIT0="no"
    fi
#   If SCRIPTLIB_TRAPWRAP_PRINT_MESSAGE==yes and we have a shell with func-call
#   history like bash, print also a stack trace of the failure?
[ -n "${SCRIPTLIB_TRAPWRAP_PRINT_STACKTRACE-}" ] && [ x"${SCRIPTLIB_TRAPWRAP_PRINT_STACKTRACE-}" != "x-" ] || \
    if [ "$ZONEMGR_DEBUG" -ge "$ZONEMGR_DEBUGLEVEL_DEBUG" ]; then
        SCRIPTLIB_TRAPWRAP_PRINT_STACKTRACE="yes"
    else
        SCRIPTLIB_TRAPWRAP_PRINT_STACKTRACE="no"
    fi

settraps() {
    # Sets up or clear traps defined in $TRAP_SIGNALS (or falls back to default
    # list of signals) to report the trap, call consumer's handler, and if that
    # routine does not exit() the shell by itself - the wrapper would exit with
    # either that handler's non-zero return code or with original trapped code.
    # The ERR* variables reported here are defined by settraps_nonfatal() above
    # Note that all output (if any) goes to stderr (see end of "if" clause).
    case "$1" in
        -|"") settraps_nonfatal "$1" || true ;;
        *)    ERRHANDLER="$*"
              case "$ERRHANDLER" in
                *";"|*"; "|*";  ") ;;
                *)    ERRHANDLER="$ERRHANDLER ;" ;;
              esac
              settraps_nonfatal 'if [ "${SCRIPTLIB_TRAPWRAP_PRINT_MESSAGE-}" = yes ]\
; then
    echo ""
    _DO_PRINT_STACKTRACE=no
    if [ "${SCRIPTLIB_TRAPWRAP_PRINT_STACKTRACE-}" = yes ] && [ -n "${BASH-}" ]; then
        _DO_PRINT_STACKTRACE=yes
    fi
    if [ "${ERRCODE-}" = 0 ]; then
        _DO_PRINT_STACKTRACE=no
        if [ "${SCRIPTLIB_TRAPWRAP_PRINT_EXIT0-}" = yes ] || \
            [ "${ERRSIGNAL-}" != 0 -a "${ERRSIGNAL-}" != EXIT -a "${ERRSIGNAL-}" != SIGEXIT ] \
        ; then
            LOGMSG_PREFIX="ZONEMGR-SIGNALTRAP-" logmsg_info "Completing ${ERRTEXT-}"
            _DO_PRINT_STACKTRACE=yes
        fi
    else
        echo ""; echo "!!!!!!!!!"
        LOGMSG_PREFIX="ZONEMGR-SIGNALTRAP-" logmsg_error "Aborting ${ERRTEXT-}"
        echo "!!!!!!!!!"
    fi
    echo ""
    if [ "${_DO_PRINT_STACKTRACE-}" = yes ]; then
        echo "======= Stack trace and other clues of the end-of-work (code=${ERRCODE-}, sig=${ERRSIGNAL-}):"
        echo "  Depth of sub-shelling (BASH_SUBSHELL) = ${BASH_SUBSHELL-}"
        if [ -z "${FUNCNAME-}" ] || [ -z "${FUNCNAME[0]}" ]; then
            FUNCDEPTH=-1
        else
            FUNCDEPTH="${#FUNCNAME[@]-}" 2>/dev/null && [ -n "$FUNCDEPTH" ] && [ "$FUNCDEPTH" -ge 0 ] || FUNCDEPTH=-1
        fi
        printf "  Depth of function call stack = $FUNCDEPTH : "
        if [ "$FUNCDEPTH" -gt 0 ] 2>/dev/null; then
            printf "::%s" ${FUNCNAME[@]-}
        else
            printf "finished in main body of main script"
        fi
        printf "\n"
        i=0
        while [ "$i" -lt "$FUNCDEPTH" ] ; do
            echo "  ($i)        -> in ${FUNCNAME[$i]-}() called at ${BASH_SOURCE[$i+1]-}:${BASH_LINENO[$i]-}"
            i=$(($i+1))
        done
        echo "  ~> in ${ERRFUNC:-main-script-body}() at ${ERRFILE-}:${ERRLINE-}"
        echo "======= End of stack trace, ${_SCRIPT_NAME-}:${LINENO-}"
        echo ""
    fi
fi >&2
settraps_exit_clear
{ '"$ERRHANDLER"' } || exit $?
exit ${ERRCODE-};' \
                || true
              ;;
    esac
}

exit_cleanup() {
    :
}

TBD() {
    if [ -n "${FUNCNAME[1]}" ]; then
        logmsg_error "Routine ${FUNCNAME[1]}() is not implemented yet"
    else
        ( die "This routine is not implemented yet" )
    fi
    false
}

############################################################################
# Slurp script configs (hardcoded defaults; system, user level and
# CLI-passed config file overrides) - e.g. container root datasets
############################################################################

usage() {
    cat << EOF
Usage: ${_SCRIPT_NAME} (options...) (action)"
Options: if conflicting options are specified, then the last one wins
(except when setting defaults for certain actions).
    -h|--help		Display this help text and exit
    --config FILE	Use a specified configuration file after parsing
			system and user-homedir default files and before
			parsing any subsequent command-line options
    --print-config	Show active configuration after parsing CLI args
    -d|--debug LEVEL	Set debugging level to the specified value
    -O|--outfile NAME	Write results of the work into the output file,
			e.g. record the created (generated) zone name there
    -n|--dry-run	Do not create/destroy/change datasets and zones,
			but only print what would be done instead
    -t|--template NAME	Use this OS-defined template to create a new GIZ
    -b|--brand NAME	Record this brand in the zone attributes
    -c|--clone|--origin	NAME	The origin GIZ for cloning into new GIZ or DIZ
    -z|--zone NAME	Target zone to create or otherwise manage
    -Z|--zone-autoname	Generate name for the zone as a hash of requested
			package names. When asked to create-diz or exec-diz,
			the script would find or create (for future reuse)
			a suitable source GIZ (maybe starting as a clone of
			specified origin, or from template)
    --exec-cmd SCRIPT	Execute the command in the zone via zlogin
    --exec-user NAME	...as the specified LZ-defined user account
    --exec-discard off|always|onsuccess	Discard the zone after running the
			command? Defaults to "off" usually, and to "always"
			for "exec-diz" action

Add LZ network interfaces as dedicated VNICs (exclusive IP mode) that will
be DHCP enabled (the GZ may serve DHCP+NAT over an etherstub for example):
    --add-vnic NAME	Assign an (additional) existing VNIC to the zone
    --add-vnic-over LINK	Temporarily create a VNIC over the specified
			link (e.g. a physical NIC or an etherstub) - it will
			be removed when the zone is destroyed by this script.
			To use advanced setup, specify LINK as pipe-separated
			tuple of "LINK[|VLAN[|MAC]]" where unspecified values
			are assumed as OS-default setting.

The following options APPEND to an existing list (so you can specify them
several times):
    -p|--add-packages LIST	Whitespace-separated list of package FMRIs to
			install when creating the zone, or to manage later
    -P|--remove-packages LIST	Whitespace-separated list of package FMRIs to
			uninstall when creating the zone, or to manage later
    -g|--add-publisher LIST	Add the specified publisher(s) when creating
			the zone or later; WS-SEP list of "pub|url" items
    -G|--remove-publisher LIST	Remove publisher URLs and/or definitions using
			same argument format as above
    --mount-lofs LIST	Set up lofs-mounting of specified paths from GZ, as a
			whitespace-separated list of "lzpath|gzpath" items
    --mount-autonfs LIST	Set up autofs-mounting of specified NFS paths,
			as whitespace-separated list of "lzpath|NFSurl" items
    --copy-users LIST	Copy listed (white-space separated) group and user
    --copy-groups LIST	account definitions from GZ to LZ (lines in file DBs)
Actions: the last specified action is performed (so please only call one).
    create-giz		Create target golden-image zone from template/origin
			(configure, install, disable auto-boot)
    create-diz		Create target disposable-image zone from origin GIZ
			(configure, install, enable auto-boot and boot up)
    exec-diz		Creates by default an auto-named zone (see "-Z" above)
			with settings specified by CLI and/or custom config,
			runs a command in this zone, and discards the zone
    exec		Using an existing zone, runs a command in it (boots
			it up if needed - and halts afterwards in this case)
    list|list-diz|list-giz	List zones managed by this script
    destroy		Uninstall and unconfigure the specified zone, and
			destroy any automatically created VNICs
    start|boot		Boot the specified zone and wait for multi-user-server
			milestone to get reached
    stop|halt		Halt the specified zone
    restart|reboot	Reboot the specified zone
    pkg-refresh		Fetch the updated packaging metadata
    pkg-upgrade		Upgrade packages installed in this zone (no refresh)
    pkg-install		Install packages specified in "-p" list
    pkg-uninstall	Uninstall packages specified in "-P" list
EOF
}

# Prefix commands that change system state with this
ELEVATE_CMD="pfexec"
OUTFILE=""

# Golden images live under this dataset
DATASET_CONTAINMENT_GIZ="rpool/zones/_zonemgr-GIZ"
# Disposable zones live under this dataset
DATASET_CONTAINMENT_DIZ="rpool/zones/_zonemgr-DIZ"
# Flip this to "yes" in a config to use "zfs create -p"
CAN_ZFS_CREATE_RECURSIVE=no
# Flip this to "on" in a config to dedup under the GIZ container
DATASET_CONTAINMENT_GIZ_DEDUP=off
# For GIZ we want strong compression, it is not written often
DATASET_CONTAINMENT_GIZ_COMPRESSION="gzip-9"
# For DIZ clones we want fast compression, like "on" or "lz4" or "zle"
DATASET_CONTAINMENT_DIZ_COMPRESSION="zle"

# Which zone template a GIZ from scratch starts with
TEMPLATE_GIZ="SUNWipkg"
BRAND_GIZ="ipkg"
# Which golden-image zone the target one (GIZ or DIZ) is cloned from
ORIGIN_GIZ=""
# Which zone will we manage with this command?
TARGET_ZONE=""

ADD_PUBLISHERS=""
DEL_PUBLISHERS=""
ADD_PACKAGE_FMRIS=""
DEL_PACKAGE_FMRIS=""
ADD_MOUNT_LOFS=""
ADD_MOUNT_AUTONFS=""
COPY_USERS=""
COPY_GROUPS=""
EXEC_CMD=""
EXEC_USER=""
EXEC_DISCARD=""
USE_VNICS=""
AUTO_VNICS=""

# What will we do?
ACTION=""
ZONECFG_SCRIPT=""

parse_config() {
    # Args: pass "$@" of the script
    for F in "/etc/zones/zonemgr.conf" "${HOME}/.zonemgr.conf" ; do
        if [ -s "$F" ] ; then
            logmsg_info "Reading config file: $F"
            . "$F" || true
        fi
    done

    DO_PRINT_CONFIG=0
    while [ "$#" -gt 0 ]; do
        case "$1" in
            -h|-help|--help) usage ; exit 0 ;;
            --config)
	        logmsg_info "Reading config file: $2"
                [ -f "$2" ] && . "$2" || exit $?
		shift
		;;
	    --print-config) DO_PRINT_CONFIG=1 ;;
	    -d|--debug) ZONEMGR_DEBUGLEVEL_INFO="$2"; shift ;;
	    -O|--outfile) OUTFILE="$2"; shift ;;
	    -n|--dryrun|--dry-run) ELEVATE_CMD="echo $ELEVATE_CMD" ;;
	    -t|--template) TEMPLATE_GIZ="$2"; shift ;;
	    -b|--brand) BRAND_GIZ="$2"; shift ;;
	    -c|--clone|--origin) ORIGIN_GIZ="$2"; shift; [ -n "$ACTION" ] || ACTION="create" ;;
	    -z|--zone) TARGET_ZONE="$2"; shift ;;
	    -Z|--zone-autoname) TARGET_ZONE='{auto}' ;;
	    -p|--add-packages|--install-packages|--add-package|--install-package)
		ADD_PACKAGE_FMRIS="$ADD_PACKAGE_FMRIS $2"; shift ;;
	    -P|--remove-packages|--del-packages|--uninstall-packages||--remove-package|--del-package|--uninstall-package)
		DEL_PACKAGE_FMRIS="$DEL_PACKAGE_FMRIS $2"; shift ;;
	    -g|--add-publisher|--add-publishers)
		ADD_PUBLISHERS="$ADD_PUBLISHERS $2"; shift ;;
	    -G|--remove-publisher|--del-publisher|--remove-publishers|--del-publishers)
		DEL_PUBLISHERS="$DEL_PUBLISHERS $2"; shift ;;
	    --mount-lofs)
		ADD_MOUNT_LOFS="$ADD_MOUNT_LOFS $2"; shift ;;
	    --mount-autonfs)
		ADD_MOUNT_AUTONFS="$ADD_MOUNT_AUTONFS $2"; shift ;;
	    --copy-users|--copy-user)
		COPY_USERS="$COPY_USERS $2"; shift ;;
	    --copy-groups|--copy-group)
		COPY_GROUPS="$COPY_GROUPS $2"; shift ;;
	    --add-vnic|--use-vnic|--add-vnics|--use-vnics)
		USE_VNICS="$USE_VNICS $2"; shift ;;
	    --add-vnic-over|--use-vnic-over|--add-vnics-over|--use-vnics-over|--auto-vnic|--auto-vnics)
		AUTO_VNICS="$AUTO_VNICS $2"; shift ;;
	    --exec-cmd) EXEC_CMD="$1" ;;
	    --exec-user) EXEC_USER="$1" ;;
	    --exec-discard)
		case "$2" in
		    off|always|onsuccess) EXEC_DISCARD="$2"; shift ;;
		    *) logmsg_error "Unknown CLI argument: $1 $2" ; exit 1 ;;
		esac
		;;
	    create-giz|create-diz|list|list-giz|list-diz|destroy|pkg-refresh|pkg-upgrade|pkg-install|pkg-uninstall) ACTION="$1" ;;
	    exec-diz|run-diz) ACTION="exec-diz"
		[ -n "$EXEC_DISCARD" ] || EXEC_DISCARD="always"
		[ -n "$TARGET_ZONE" ] || TARGET_ZONE='{auto}'
		;;
	    start|boot) ACTION="boot" ;;
	    stop|halt|poweroff) ACTION="halt" ;;
	    restart|reboot|reset) ACTION="reboot" ;;
            *) logmsg_error "Unknown CLI argument: $1" ; exit 1 ;;
        esac
        shift
    done
    [ -n "$EXEC_DISCARD" ] || EXEC_DISCARD="off"

    if [ "$DO_PRINT_CONFIG" = 1 ] || [ "$ZONEMGR_DEBUGLEVEL" -gt "$ZONEMGR_DEBUGLEVEL_INFO" ]; then
        print_config
    fi

    ZONECFG_SCRIPT=""
}

print_config() {
    logmsg_info "Currently active configuration variables of ${_SCRIPT_NAME} ${_SCRIPT_ARGS}:" \
        "DATASET_CONTAINMENT_GIZ='$DATASET_CONTAINMENT_GIZ'" \
	"DATASET_CONTAINMENT_GIZ_DEDUP='$DATASET_CONTAINMENT_GIZ_DEDUP'" \
	"DATASET_CONTAINMENT_GIZ_COMPRESSION='$DATASET_CONTAINMENT_GIZ_COMPRESSION'" \
        "DATASET_CONTAINMENT_DIZ='$DATASET_CONTAINMENT_DIZ'" \
	"DATASET_CONTAINMENT_DIZ_COMPRESSION='$DATASET_CONTAINMENT_DIZ_COMPRESSION'" \
	"CAN_ZFS_CREATE_RECURSIVE='$CAN_ZFS_CREATE_RECURSIVE'" \
	"TARGET_ZONE='$TARGET_ZONE'" \
	"ORIGIN_GIZ='$ORIGIN_GIZ'" \
	"TEMPLATE_GIZ='$TEMPLATE_GIZ'" \
	"ADD_PUBLISHERS='$ADD_PUBLISHERS'" \
	"DEL_PUBLISHERS='$DEL_PUBLISHERS'" \
	"ADD_PACKAGE_FMRIS='$ADD_PACKAGE_FMRIS'" \
	"DEL_PACKAGE_FMRIS='$DEL_PACKAGE_FMRIS'" \
	"ADD_MOUNT_LOFS='$ADD_MOUNT_LOFS'" \
	"ADD_MOUNT_AUTONFS='$ADD_MOUNT_AUTONFS'" \
	"COPY_USERS='$COPY_USERS'" \
	"COPY_GROUPS='$COPY_GROUPS'" \
	"USE_VNICS='$USE_VNICS'" \
	"AUTO_VNICS='$AUTO_VNICS'" \
	"EXEC_CMD='$EXEC_CMD'" \
	"EXEC_USER='$EXEC_USER'" \
	"EXEC_DISCARD='$EXEC_DISCARD'" \
	"OUTFILE='$OUTFILE'" \
	"ELEVATE_CMD='$ELEVATE_CMD'" \
	"ACTION='$ACTION'"
}

############################################################################
# Zone-creation task stack:
############################################################################

zfs_dataset_exists() {
    test "$(zfs list -H -o name "$1")" = "$1"
}

zfs_create_recursive() {
    # Newer "zfs" command is able to create parent datasets; older ones can't.
    # Last arg is assumed to be dataset name; passes other args to the last
    # called "zfs" command (so e.g. options are applied to the target one).
    [ "$#" -gt 0 ] && \
        TARGET_DS="$(while [ "$#" -gt 1 ]; do shift; done; echo "$1")" \
	|| TARGET_DS=""

    case "$TARGET_DS" in
        ""|-*|/*|*/) die "Bad args to zfs_create_recursive()" ;;
	*/*) TARGET_POOL="$(echo "$TARGET_DS" | sed -e ',^\([^/]*\)/.*,\1,')"
	    if ! zfs_dataset_exists "$TARGET_POOL" ] || \
	       ! zpool list "$TARGET_POOL" \
	    ; then
	        die "zfs_create_recursive() requested for '$TARGET_DS' in non-existent pool '$TARGET_POOL'"
	    fi
	    ;;
	*)  die "Bad args to zfs_create_recursive()" ;;
    esac

    if zfs_dataset_exists "$TARGET_DS" ; then
        logmsg_debug "$TARGET_DS already exists, nothing to do for zfs_create_recursive()"
        # Note: we do not apply requested -o(ptions) to pre-existing dataset
        return 0
    fi

    if [ "$CAN_ZFS_CREATE_RECURSIVE" = yes ]; then
        $ELEVATE_CMD zfs create -p "$@"
	return $?
    else
        # Create parents, recursively - no extra options
        zfs_create_recursive "$(dirname "$TARGET_DS")" || return $?
        # Finally (in top call) create the dataset maybe with extra options
        $ELEVATE_CMD zfs create "$@"
	return $?
    fi
}

create_dataset_containment_GIZ() {
    # Create the golden-image containment dataset if missing yet
    # * Disable auto-snaps
    # * Disable atime (writes during reads)
    # * Enable strong compression
    # * Enable dedup?
    if zfs_dataset_exists "$DATASET_CONTAINMENT_GIZ" ; then
        logmsg_debug "$DATASET_CONTAINMENT_GIZ already exists, nothing to do for create_dataset_containment_GIZ()"
        # Note: we do not apply custom options to pre-existing dataset
        return 0
    fi

    # Newer versions might get away with "zfs create -o k=v [...] dataset"
    # but older ones do not have this luxury - so we portably do it as a
    # chain of commands.
    # TODO: Wrap into "zfs_create_recursive -o ..." with a flag variable.
    zfs_create_recursive "$DATASET_CONTAINMENT_GIZ" || \
        die "create_dataset_containment_GIZ(): Could not create '$DATASET_CONTAINMENT_GIZ'"

    zfs set -o atime=off "$DATASET_CONTAINMENT_GIZ"
    zfs set -o compression="$DATASET_CONTAINMENT_GIZ_COMPRESSION" "$DATASET_CONTAINMENT_GIZ"
    zfs set -o com.sun:auto-snapshot=false "$DATASET_CONTAINMENT_GIZ" || true
    case "$DATASET_CONTAINMENT_GIZ_DEDUP" in
        on|off)
            zfs set -o dedup="$DATASET_CONTAINMENT_GIZ_DEDUP" "$DATASET_CONTAINMENT_GIZ" || true ;;
    esac
}

create_dataset_containment_DIZ() {
    # Create the disposable-zone containment dataset if missing yet:
    # * Disable auto-snaps
    # * Enable moderate or no compression
    # * Disable dedup
    if zfs_dataset_exists "$DATASET_CONTAINMENT_DIZ" ; then
        logmsg_debug "$DATASET_CONTAINMENT_DIZ already exists, nothing to do for create_dataset_containment_DIZ()"
        # Note: we do not apply custom options to pre-existing dataset
        return 0
    fi

    zfs_create_recursive "$DATASET_CONTAINMENT_DIZ" || \
        die "create_dataset_containment_DIZ(): Could not create '$DATASET_CONTAINMENT_DIZ'"

    zfs set -o atime=off "$DATASET_CONTAINMENT_DIZ"
    zfs set -o compression="$DATASET_CONTAINMENT_DIZ_COMPRESSION" "$DATASET_CONTAINMENT_DIZ"
    zfs set -o com.sun:auto-snapshot=false "$DATASET_CONTAINMENT_DIZ" || true
    zfs set -o dedup=off "$DATASET_CONTAINMENT_DIZ" || true
}

############################################################################
# Create the golden-image zone from scratch, if the name is not yet occupied:
############################################################################

# Let specify image template type (linked, brand, etc.) to set up the config
zonecfg_create() {
    if [ -n "$ORIGIN_GIZ" ] ; then
        echo "create -t $ORIGIN_GIZ"
    else
        if [ -n "$TEMPLATE_GIZ" ] ; then
            echo "create -t $TEMPLATE_GIZ"
        else
    	echo "create -b"
            [ -z "$BRAND_GIZ" ] || echo "set brand=$BRAND_GIZ"
        fi
    fi
}

# Minimal config zone-wise (no resources, filesystem/dataset provisions,
# exclusive networking, user accounts...); set autoboot:=false
zonecfg_basics() {
    [ -n "$TARGET_ZONE" ] || die "TARGET_ZONE is not defined"
    cat << EOF
set ip-type=exclusive
set autoboot=false
EOF
    case "$ACTION" in
	create-giz) echo "set zonepath=$DATASET_CONTAINMENT_GIZ/$TARGET_ZONE" ;;
	create-diz) echo "set zonepath=$DATASET_CONTAINMENT_DIZ/$TARGET_ZONE" ;;
	*) logmsg_warn "Uncertain which containment dataset to use for ACTION='$ACTION'" ;;
    esac
}

# Let specify package source(s) - URL to IPS repo, possibly just one
# publisher may be allowed for initial installation, but more may be added
# after initial "image" setup (TBD)

# Consider packaging, tarballs, zfs-send images to instantiate zone root (TBD)

############################################################################
# Create a golden-image zone from existing golden-image zone (clone current
# state, last or specified snapshot):
############################################################################

# Add metadata (zonecfg field?) to track which GIZ this image was built from
zonecfg_attr_origin() {
    VAL="undefined"
    if [ -n "$ORIGIN_GIZ" ] ; then
        VAL="giz:$ORIGIN_GIZ"
    else
        if [ -n "$TEMPLATE_GIZ" ] ; then
            VAL="template:$TEMPLATE_GIZ"
        else
            [ -n "$BRAND_GIZ" ] && VAL="brand:$BRAND_GIZ" || VAL="blank"
        fi
    fi

    cat << EOF
add attr
set name=origin
set type=string
set value="$VAL"
end
EOF
    unset VAL
}


# Specify package(s) to remove from the zone compared to original while
# creating it (e.g. to avoid conflicts for subsequently added packages) - TBD

# Specify package(s) to add into the zone compared to original while creating

# Same limitations (e.g. simplicity of config) as above

############################################################################
# Create a disposable zone from specified golden-image zone (clone current
# state, last or specified snapshot):
############################################################################

# Manage VNICs?
create_vnic() {
    # input value is "LINK[|VLAN[|MAC]]" with returned vnic name based on
    # value of TARGET_ZONE (if present)
    LINK="$(echo "$1" | (IFS='|' read L V M ; echo "$L"))"
    if [ -z "$LINK" ]; then
	logmsg_error "Did not find a LINK in specified arguments: '$1'"
	return 1
    fi
    VLAN="$(echo "$1" | (IFS='|' read L V M ; echo "$V"))"
    MACADDR="$(echo "$1" | (IFS='|' read L V M ; echo "$M"))"

    case "$ACTION" in
	create-giz) VNIC="autogiz${TARGET_ZONE}" ;;
	create-diz) VNIC="autodiz${TARGET_ZONE}" ;;
	*) logmsg_warn "Uncertain which VNIC name pattern to use for ACTION='$ACTION'"
	   VNIC="auto${TARGET_ZONE}" ;;
    esac
    VNIC="${VNIC}$(dladm show-vnic | egrep -c "^${VNIC}"'[0-9]*[ \t]')"

    DLADM_ARGS="-l ${LINK}"
    [ -z "$MAC" ] || DLADM_ARGS="$DLADM_ARGS -m ${MAC}"
    [ -z "$VLAN" ] || DLADM_ARGS="$DLADM_ARGS -v ${VLAN}"

    $ELEVATE_CMD dladm create-vnic $DLADM_ARGS "$VNIC" && \
    echo "$VNIC"
}

delete_vnic() {
    $ELEVATE_CMD dladm delete-vnic "$1"
}

# Add resource definitions (datasets/lofs, network, user accounts/ldap, ...)
zonecfg_assign_vnic() {
    cat << EOF
add net
set physical=$1
end
EOF
}

zonecfg_auto_vnics() {
    VNICS=""
    for LVM in $AUTO_VNICS ; do
        NEWVNIC="$(create_vnic "$LVM")" && [ -n "$NEWVNIC" ] || die "Failed to create VNIC by spec: $LVM"
        VNICS="$VNICS $NEWVNIC"
        zonecfg_assign_vnic "$NEWVNIC"
    done
    if [ -n "$VNICS" ]; then
         cat << EOF
add attr
set name=autovnic
set type=string
set value="$VNICS"
end
EOF
    fi
}

# Script cloning of file-based user/shadow and group account data from GZ
# to LZ for respective specified accounts
clone_group() {
    TBD
}

clone_user() {
    TBD
}

############################################################################
# General maintenance actions:
############################################################################

# List all managed, or only GIZ/DIZ zones (roots under our container datasets)

# Iterate all golden-image zones to upgrade them (e.g. from crontab)

############################################################################
# General actions against any managed zones (GIZ or DIZ):
############################################################################

# Generate a unique name-part for the zone (hash of concat of sorted requested
# pkg names?) that may get prefixed and/or suffixed for GIZ and DIZ instances

# Snapshot a zone

# Clone a zone (clone current state, last or specified snapshot)

# pkg-update contents of a (golden-image?) zone, snapshot after success

# Install specified package(s) into the named zone, snapshot after success

# Start, stop a zone

# Destroy a zone (including config)

# Halt and roll back to specified snapshot (e.g. reuse same)

# Run a command inside the zone (via zlogin), maybe as a specified account

############################################################################
# Do the run-time work
############################################################################

# Allow to togle shell-tracing in ZONEMGR-driven builds more easily
if [ "$ZONEMGR_DEBUG" -ge "$ZONEMGR_DEBUGLEVEL_TRACEEXEC" ] ; then
    logmsg_info "ZONEMGR_DEBUG is $ZONEMGR_DEBUG >= $ZONEMGR_DEBUGLEVEL_TRACEEXEC : enabling source-code tracing!" >&2
    set -x
fi

settraps "exit_cleanup"

parse_config "$@"

create_dataset_containment_GIZ
:

